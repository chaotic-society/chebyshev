
///
/// @file random.h The pseudorandom number generation and sampling module.
///

#ifndef CHEBYSHEV_RANDOM_H
#define CHEBYSHEV_RANDOM_H

#include <cstdlib>
#include <cmath>
#include "../core/common.h"


namespace chebyshev {

	/// @namespace chebyshev::random
	/// Pseudorandom number generation and sampling module.
	namespace random {


		/// @class random_settings
		/// Settings for the random module
		struct random_settings {
			
			/// The seed for random number generation
			uint64_t seed = 0;

		} settings;


		/// Initialize the random module.
		inline void setup(uint64_t seed = 0) {

			if(seed == 0)
				seed = time(nullptr);

			settings.seed = seed;
			srand(settings.seed);
		}


		/// Generate a random natural number.
		inline uint64_t natural() {
			return rand();
		}


		/// Generate a uniformly distributed random number.
		///
		/// @param a The lower extreme of the interval
		/// @param b The upper extreme of the interval
		/// @return A pseudorandom number uniformly
		/// distributed over (a, b).
		inline long double uniform(long double a, long double b) {
			return (rand() / (long double) RAND_MAX) * (b - a) + a;
		}


		/// Fill an already allocated vector with uniformly
		/// distributed numbers over different intervals.
		///
		/// @param x The already initialized vector to fill.
		/// @param intervals The intervals to generate over.
		/// @return A reference to the overwritten vector.
		template<typename Vector>
		inline Vector& sample_uniform(Vector& x, const std::vector<prec::interval> intervals) {

			if(x.size() != intervals.size())
				throw std::runtime_error(
					"Vector and domain size mismatch in chebyshev::sample_uniform");

			for (int i = 0; i < x.size(); ++i)
				x[i] = uniform(intervals[i].a, intervals[i].b);
		
			return x;
		}


		/// Generate a Gaussian distributed random number.
		///
		/// @param m The mean of the distribution
		/// @param s The standard deviation of the distribution
		/// @return A pseudorandom number Gaussian distributed.
		inline long double gaussian(long double m, long double s) {

			const long double x = uniform(0.0, 1.0);
			const long double y = uniform(0.0, 1.0);

			const long double v = std::sqrt(-2 * std::log(x));
			const long double u = v * std::cos(2 * PI_CONST * y);

			return m + s * u;
		}


		/// Generate a random string made of human-readable
		/// ASCII characters.
		///
		/// @param length The length of the string to generate
		/// @return A string generated by choosing the elements
		/// of the alphabet with uniform probability.
		inline std::string string(size_t length) {

			std::string str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = '!' + (char) (natural() % 95);

			return str;
		}


		/// Generate a random string made of the elements
		/// of the given alphabet.
		///
		/// @param length The length of the string to generate
		/// @param alphabet A string containing the elements of the alphabet.
		/// @return A string generated by choosing the elements
		/// of the alphabet with uniform probability.
		inline std::string string(size_t length, std::string alphabet) {

			if(!alphabet.size())
				throw std::runtime_error("alphabet in chebyshev::random::string cannot be empty.");

			std::string str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = alphabet[natural() % alphabet.size()];

			return str;
		}


		/// Generate a random string made of the elements
		/// of the given alphabet.
		///
		/// @param length The length of the string to generate.
		/// @param alphabet A vector containing the elements of the alphabet.
		/// @return A string generated by choosing the elements
		/// of the alphabet with uniform probability.
		inline std::string string(size_t length, std::vector<char> alphabet) {

			if(!alphabet.size())
				throw std::runtime_error("alphabet in chebyshev::random::string cannot be empty.");

			std::string str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = alphabet[natural() % alphabet.size()];

			return str;
		}


		/// Generate a random string made of the elements
		/// of the given alphabet, of arbitrary type.
		///
		/// @param length The length of the string to generate
		/// @return A vector generated by choosing the elements
		/// of the alphabet with uniform probability.
		template<typename T>
		inline std::vector<T> string(size_t length, std::vector<T> alphabet) {

			if(!alphabet.size())
				throw std::runtime_error("alphabet in chebyshev::random::string cannot be empty.");

			std::vector<T> str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = alphabet[natural() % alphabet.size()];

			return str;
		}

	}
}

#endif
