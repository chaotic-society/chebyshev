
///
/// @file random.h The pseudorandom number generation and sampling module.
///

#ifndef CHEBYSHEV_RANDOM_H
#define CHEBYSHEV_RANDOM_H

#include <cstdint>
#include <cstdlib>
#include <cmath>
#include <mutex>


#include "../core/common.h"


/// Define the CH_CUSTOM_RND macro and a type
/// random_engine to use a custom random number generator.
/// By default, the standard Mersenne Twister is used.
#ifndef CH_CUSTOM_RND

#include <random>
using random_engine = std::mt19937;

#endif


namespace chebyshev {

/// @namespace chebyshev::random
/// Pseudorandom number generation and sampling module.
namespace random {


	/// @class random_source
	/// A source of pseudorandom numbers.
	/// Can be automatically generated from a random_context by using get_rnd().
	struct random_source {
		
	private:
		
		/// The underlying random source
		random_engine rnd;

		/// The seed used to initialize the generator.
		uint64_t seed {0};

	public:

		/// Construct a random engine with the given seed
		random_source(uint64_t seed) {
			this->seed = seed;
			rnd = random_engine(seed);
		}


		/// Get the seed used to generate the random source.
		uint64_t get_seed() {
			return seed;
		}


		/// Generate a random natural number.
		inline uint64_t natural() {
			return rnd();
		}


		/// Generate a uniformly distributed random number.
		///
		/// @param a The lower extreme of the interval
		/// @param b The upper extreme of the interval
		/// @return A pseudorandom number uniformly
		/// distributed over (a, b).
		inline real_t uniform(real_t a, real_t b) {

			const uint64_t max = uint64_t(1) << 31;
			const real_t u = (natural() % max) / prec_t(max);
			
			return u * (b - a) + a;
		}


		/// Fill an already allocated vector with uniformly
		/// distributed numbers over the same interval.
		///
		/// @param x The already initialized vector to fill.
		/// @param a The lower extreme of the interval
		/// @param b The upper extreme of the interval
		/// @return A reference to the overwritten vector.
		template<typename Vector>
		inline Vector& uniform(Vector& x, real_t a, real_t b) {

			for (auto& x_i : x)
				x_i = uniform(a, b);
		
			return x;
		}


		/// Fill an already allocated vector with uniformly
		/// distributed numbers over different intervals.
		///
		/// @param x The already initialized vector to fill.
		/// @param intervals The intervals to generate over.
		/// @return A reference to the overwritten vector.
		template<typename Vector>
		inline Vector& uniform(Vector& x, const std::vector<prec::interval> intervals) {

			if(x.size() != intervals.size()) {
				throw std::runtime_error(
					"Vector and domain size mismatch in chebyshev::uniform"
				);
			}

			for (unsigned int i = 0; i < x.size(); ++i)
				x[i] = uniform(intervals[i].a, intervals[i].b);
		
			return x;
		}


		/// Generate a Gaussian distributed random number.
		///
		/// @param m The mean of the distribution
		/// @param s The standard deviation of the distribution
		/// @return A pseudorandom number Gaussian distributed.
		inline real_t gaussian(real_t mean, real_t sigma) {

			const real_t x = uniform(0.0, 1.0);
			const real_t y = uniform(0.0, 1.0);

			const real_t v = std::sqrt(-2 * std::log(x));
			const real_t u = v * std::cos(2 * PI_CONST * y);

			return mean + sigma * u;
		}


		/// Fill an already allocated vector with Gaussian
		/// distributed numbers with the same mean and standard deviation.
		///
		/// @param x The already initialized vector to fill.
		/// @param m The mean of the distribution
		/// @param s The standard deviation of the distribution
		/// @return A reference to the overwritten vector.
		template<typename Vector>
		inline Vector& gaussian(Vector& x, real_t mean, real_t sigma) {

			for (auto& x_i : x)
				x_i = gaussian(mean, sigma);
		
			return x;
		}


		/// Generate a random string made of human-readable
		/// ASCII characters.
		///
		/// @param length The length of the string to generate
		/// @return A string generated by choosing the elements
		/// of the alphabet with uniform probability.
		inline std::string string(size_t length) {

			std::string str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = '!' + (char) (natural() % 95);

			return str;
		}


		/// Generate a random string made of the elements
		/// of the given alphabet.
		///
		/// @param length The length of the string to generate
		/// @param alphabet A string containing the elements of the alphabet.
		/// @return A string generated by choosing the elements
		/// of the alphabet with uniform probability.
		inline std::string string(size_t length, std::string alphabet) {

			if(!alphabet.size()) {
				throw std::runtime_error(
					"alphabet in chebyshev::random::string cannot be empty."
				);
			}

			std::string str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = alphabet[natural() % alphabet.size()];

			return str;
		}


		/// Generate a random string made of the elements
		/// of the given alphabet.
		///
		/// @param length The length of the string to generate.
		/// @param alphabet A vector containing the elements of the alphabet.
		/// @return A string generated by choosing the elements
		/// of the alphabet with uniform probability.
		inline std::string string(size_t length, std::vector<char> alphabet) {

			if(!alphabet.size()) {
				throw std::runtime_error(
					"alphabet in chebyshev::random::string cannot be empty."
				);
			}

			std::string str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = alphabet[natural() % alphabet.size()];

			return str;
		}


		/// Generate a random string made of the elements
		/// of the given alphabet, of arbitrary type.
		///
		/// @param length The length of the string to generate
		/// @return A vector generated by choosing the elements
		/// of the alphabet with uniform probability.
		template<typename T>
		inline std::vector<T> string(size_t length, std::vector<T> alphabet) {

			if(!alphabet.size()) {
				throw std::runtime_error(
					"alphabet in chebyshev::random::string cannot be empty."
				);
			}

			std::vector<T> str;
			str.resize(length);

			for (unsigned int i = 0; i < length; ++i)
				str[i] = alphabet[natural() % alphabet.size()];

			return str;
		}

	};


	/// @class random_settings
	/// Settings for the random module
	struct random_settings { };


	/// @class random_context Random module context.
	class random_context {
	private:

		/// The random generator which will be used to seed all PRNGs.
		random_engine rnd;

		/// Mutex to lock access to the random_engine
		std::mutex rndMutex;

	public:

		/// Settings for the random context.
		random_settings settings;

		/// Initialize the random module with the given seed.
		/// If no seed is provided, a random entropy source
		/// is used instead.
    		inline void setup(uint64_t seed = 0) {
		
			if(seed == 0) {
				std::random_device entropy;
				seed = entropy();
			}

			// Initialize the random source
			rnd = random_engine(seed);
		}


		/// Terminate the random module (currently empty).
		inline void terminate() { }


		/// Initialize the random module with the given seed.
		random_context(uint64_t seed = 0) {
			setup(seed);
		}

		/// Custom copy constructor to avoid copying std::mutex.
		random_context(const random_context& other) {

			rnd = other.rnd;
			settings = other.settings;
		}


		/// Custom assignment operator to avoid copying std::mutex.
		inline random_context& operator=(const random_context& other) {

			rnd = other.rnd;
			settings = other.settings;
			return *this;
		}


		/// Instantiate a new random source,
		/// automatically seeded with a new random seed.
		inline random_source get_rnd() {

			std::lock_guard<std::mutex> lock(rndMutex);
			return random_source(rnd());
		}
		
	};

}}

#endif
